# 6장#3_정렬_알고리즘_병합_힙_도수

## 병합정렬

### 병합정렬이란?

- 두 부분으로 나누어 각각 정렬 후 병합하는 작업을 반복하는 알고리즘이다.
- 배열요소가 n개라면 n/2, n/2/2…로 나누어 재귀호출로 정렬한다.
- 병합정렬 알고리즘
    1. 배열을 앞 부분과 뒷 부분 두 부분으로 나눈다.
    2. 각 부분을 병합정렬로 정렬한다.
    3. 앞 부분과 뒷 부분을 병합한다.
    4. 배열 부분의 요솟수가 2개 이상인 동안 1-3을  반복한다.

- 정렬된 두 배열의 병합방법
    1. a배열, b배열, 결과배열의 포인터를 0으로 초기화
    2. a배열과 b배열 비교하고 작은 요소를 결과배열에 넣는다
    3. 작은 것을 넣은 배열의 포인터+1
    4. 각 배열에 남은 요소 있다면 차례로 결과배열에 넣는다.

<br>

- 책에서는 병합을 진행할 때 버퍼를 사용해서 a 배열 앞 부분을 담은 후, a 배열 뒷 부분과 버퍼를 가지고 a배열을 결과 배열로 해서 병합을 진행한다.
    - a배열 앞 부분 → buffer
    - buffer와 뒷 부분 비교하며 a배열에 저장

<br>

- 시간복잡도는 배열 병합 O(n)과 병합정렬 O(logn)이므로 총 O(nlogn)
- 서로 떨어져있는 요소를 직접 교환하는 경우가 없으므로 안정한 정렬방법이다.

<br>

### java.utils.Arrays의 sort메소드

[Arrays.sort()](https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#sort(int[]))

- 배열을 정렬하는 내장함수로 배열 다음 인수로 시작 인덱스와 종료인덱스를 주어 정렬할 범위를 정할 수도 있다.
- 범위에 맞지 않는 인덱스를 넘기면 IllegalArgumentException이나 ArrayIndexOutOfBoundsException 처리된다.
- Arrays.sort() 내부 정렬 알고리즘
    
    sort메소드는 퀵 정렬을 개선한 것으로 안정적이지는 않다.
    
    Dual-Pivot Quicksort → pivot을 두개 만들어서 그룹을 3개를 만들면서 진행
    
- 자연정렬이 되는 것은 단순히 대소관계 비교해서 정렬하고 객체와 같이 자연정렬이 안되는 것은 [Comparator](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Comparator.html)를 사용해서 정렬한다.

<br>

---

## 힙 정렬

### 힙 정렬이란?

- 힙(heap)이란?
    
    힙은 **부모요소가 자식요소보다 항상 큰 값을 가지거나 항상 작은 값을 가지는** [완전이진트리](https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%8A%B8%EB%A6%AC)이다.
    
- 형제 요소끼리의 대소는 상관없다.
- 힙 정렬을 하기 위해 요소를 배열에 저장하는데 왼쪽에서 오른쪽으로 부모부터 자식쪽으로 저장한다.
- 배열에 저장하면 부모와 자식 사이에 인덱스 규칙이 생긴다.
    
    ```java
    배열 a에서 탐색하고 있는 인덱스가 i라면,
    부모는 a[(i-1) / 2]
    왼쪽 자식은 a[i * 2 + 1]
    오른쪽 자식은 a[i * 2 + 2]
    ```
    

- 루트가 가장 큰(혹은 작은) 값을 가진다는 것을 이용해서
- 힙 정렬 알고리즘
    1. 루트 꺼내서 마지막 자리(인덱스n-1, n-2, n-3…)로 보냄
    2. 마지막에 있던 요소를 루트로 해서 나머지 부분 힙으로 만들기
    3. 1과 2를 반복하기
- 나머지 부분을 힙으로 만드는 방법
    1. 루트를 없앤 후 가장 마지막 요소를 루트로 옮긴다.
    2. 두 개의 자식 중 큰 값을 가지는 자식과 교환가능할 때까지 옮긴다.

- 정렬을 실행하려면 초기상태의 배열 또한 힙 상태여야 한다.
- 따라서 제일 아래 오른쪽 부분트리부터 하나씩 힙을 만들어서 확장한다.
    - 책에서는 배열, 시작인덱스, 종료인덱스를 매개변수로 받아서 초기배열과 정렬 중간중간 힙을 만들어주는 메소드를 정의했다. downHeap()
- 선택 정렬을 응용한 알고리즘이다. 요소가 n개라면 n개중에서 가장 큰(작은)값, n-1개 중에서 가장 큰(작은)값, n-2개 중에서 가장 큰(작은)값 …

- 시간복잡도는 가장 큰요소를 선택하는 데 O(n) 배열을 힙정렬 O(logn)이므로 O(logn)

<br>

![Untitled](https://user-images.githubusercontent.com/69182630/226178542-666435b5-4d3f-4fac-aaac-f6eb1bcee301.png)


---

## 도수 정렬

### 도수정렬

지금까지의 정렬 알고리즘과는 다르게 요소의 대소를 판단하지 않고 정렬한다.

- 도수정렬 알고리즘
    1. 도수분포표
        
        주어진 배열과 같은 크기의 배열을 생성 및 초기화한 후 각 요소 값에 해당하는 인덱스를 +1 해준다
        
    2. 누적도수분포표
        
        인덱스 1부터 n-1까지 인덱스 값을 자신의이전 인덱스들의 값을 누적해서 더한 값으로 업데이트 한다.
        
    3. 결과 배열 만들기
        
        주어진 배열에서의 값이 누적도수분포표에서의 인덱스, 누적도수분포표에서의 값이 결과 배열의 인덱스이다.
        
        결과 배열에 값 저장한 후 누적도수분포표에서의 값을 -1해준다. 누적값 중 1개를 저장했기 때문에 빼준다.
        
    4. 배열 복사하기
        
        결과 배열을 주어진 배열에 복사한다.

<br>
        
- 비교, 교환하는 작업이 없어 반복으로만 알고리즘을 처리한다.
- 순서대로 스캔하므로 안정된 정렬이지만 누적도수분포표를 처리할 때는 뒤에서부터 스캔해야 누적값을 처리하면서 진행할 수 있기 때문에 안정적일 수 있다.