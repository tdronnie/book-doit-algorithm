# 8장#1_포인터_연결리스트

## 리스트

- 데이터를 순서대로 나열해 놓은 자료구조
- 선형 구조를 가지는 리스트에는 선형 리스트와 연결 리스트가 있다.
    - 선형 리스트 → 연속하는 메모리  공간에 저장
    - 연결 리스트 → 데이터 안에 다음 데이터에 대한 정보를 가지고 있어 서로 연결
- 리스트의 개별 요소를 노드라고 하고 노드는 데이터와 다음 노드르 가리키는 포인터로 구성된다.
- 머리노드 - 꼬리노드, 앞쪽노드와 다음노드

### 선형 리스트

배열로 구현한 선형 리스트에서

다음 노드를 꺼내기 위해서는 인덱스+1인 요소에 접근한다.

노드를 삽입하기 위해서는 삽입 요소 이후의 모든 요소를 뒤로 밀어야 한다.

노드를 삭제하기 위해서는 삭제 요소 이후의 모든 요소를 앞으로 당겨야 한다.

**이에 따라 선형 리스트는 리스트의 크기를 제한해야하고 삽입 삭제 시 효율이 좋지 않다.**

**배열의 크기와 실제 저장 데이터 수에 따른 메모리 비효율이 발생할 수 있다.**

배열 크기 > 데이터 수 → 낭비

### 링크드 리스트

데이터 필드와 참조용 필드를 가지는 노드 클래스를 이용한다.

데이터 필드는 데이터 자체가 아닌 데이터가 담긴 인스턴스에 대한 참조이다.

꼬리 노드의 참조용 필드는 null을 참조한다.

- 링크드 리스트 클래스 구성
    
    **Node<E> 노드 클래스**
    
    - E data → 데이터
    - Node<E> next → 바로 뒤의 포인터
    - 생성자
    
    **Node<E> head** → 머리 노드 포인터
    
    **Node<E> crnt** → 현재 가리키는 노드 포인터
    
    **현재 가리키는 포인터를 어디에 사용할까?**
    
    → 노드 검색 후 바로 뒤의 노드를 삭제하기 위한 용도
    
    노드 삭제 후 바로 앞의 노드를 가리키기 위함
    
    **search(E, Comparator)** → 선형 검색으로 노드 검색하는 메소드
    
    - 노드의 데이터에 대해 Comparator로 비교한다.
    
    **addFirst(E)** → 리스트 머리에 노드 삽입하는 메소드
    
    - head 포인터를 삽입노드와 연결시키고 삽입노드의 next 포인터를 삽입전 머리노드로 변경한다.
    
    **addLast(E)** → 리스트 꼬리에 노드 삽입하는 메소드
    
    - 리스트가 비어있을 경우 addFirst()로 처리한다.
    
    **removeFirst()** → 머리노드를 삭제하는 메소드
    
    - 리스트가 비어있지 않을 경우에 머리노드 삭제, 삭제 후 head 포인터가 이전 머리노드 다음노드를 가리키도록 한다.
    - 리스트에 노드가 하나만 있는 경우에도 head포인터를 null로 해주어 삭제할 수 있다.
    
    **removeLast()** → 꼬리노드를 삭제하는 메소드
    
    - 리스트에 노드가 1개만 있는 경우 removeFirst()로 처리한다.
    
    **remove(Node)** → 임의의 노드를 삭제하는 메소드
    
    - 삭제하려는 노드가 머리노드인 경우 removeFirst()로 처리한다.
    
    **removeCurrentNode()** → 현재 선택한 노드를 삭제하는 메소드
    
    - remove(crnt)로 처리한다. 임의의 노드를 선택하는 메소드에 현재 포인터를 넘겨 처리요청
    
    **clear()** → 모든 노드를 삭제하는 메소드
    
    - head == null까지 removeFirst()를 진행한다.
    
    **next()** → 선택 노드를 다음 노드로 나아가게 하는 메소드
    
    - 뒤쪽 노드가 있다면 true, 없다면 false를 리턴한다.
    
    **printCurrentNode()** → crnt가 참조하는 data에 대해 묵시적으로 toString()이 호출되어 문자열로 보여준다.
    
    **dump()** → 리스트 순서대로 모든 노드를 출력한다. crnt 포인터값은 업데이트 되지 않는다.
    

- 중복되는 노드들을 가장 앞 노드만 남기고 모두 삭제하는 메소드 추가하기
    
    void purge(Comparator<? super E> c)
    
    ```java
    public void purge(Comparator<? super E> c) {
    		Node<E> ptr = head; //처음부터 검색위한 포인터 설정
    
    		while (ptr != null) { //선형 검색
    			int count = 0;
    			Node<E> ptr2 = ptr; //비교 포인터
    			Node<E> pre = ptr; //탐색 포인터
    
    			while (pre.next != null) {
    				ptr2 = pre.next; //비교하기 위한 포인터를 탐색한 그다음 포인터로 변경
    				if (c.compare(ptr.data, ptr2.data) == 0) { //타겟 데이터와 같은 비교 포인터의 데이터와 같을 경우
    					pre.next = ptr2.next; //삭제 위해 다음 참조지점을 그 다음으로 넘김
    					count++; //중복되는 노드 개수 + 1
    				} else
    					pre = ptr2; //탐색 포인터를  비교완료한 포인터로 업데이트
    			}
    			if (count == 0) //중복되는 노드가 없었다면
    				ptr = ptr.next; //다음으로 포인터 넘김
    			else {
    				Node<E> temp = ptr; //현재 포인터 저장해두고
    				remove(ptr); //현재 포인터 노드 삭제
    				ptr = temp.next; //현재 포인터를 다음 포인터로 업데이트
    			}
    		}
    		crnt = head; //현재 포인터를 머리노드 포인터로 다시 업데이트 해놓는다.
    	}
    ```
    
- 머리노드부터 n개 뒤의 노드 포인터를 리턴하는 메소드 추가하기
    
    E retrieve(int n)
    
    ```java
    public E retrieve(int n) {
    		Node<E> ptr = head; //처음부터 검색
    
    		while (n >= 0 && ptr != null) { //n번 남은 동안, 포인터 null전까지
    			if (n-- == 0) { //n이 0될 때까지 마이너스
    				crnt = ptr; //움직인 포인터를 현재 포인터로 업데이트
    				return ptr.data; // 검색 성공
    			}
    			ptr = ptr.next; // 다음 노드를 선택
    		}
    		return null; //n번 뒤의 노드가 없거나
    	}
    ```
    

---

### toString()

- java.lang 패키지의 Object 클래스에 정의된 메소드
- Object클래스에서는 “클래스이름@해시값” 형태로 문자열을 리턴한다.
- 해당 메소드를 상속받아 오버라이드해서 사용할 수 있다.