# 10장_해시

## 해시법

정렬된 배열에서의 요소삽입과 삭제는 O(n)의 시간이 걸리므로 작지 않은 비용이 든다.

이와 달리 해시법은 데이터를 저장한 위치(인덱스)를 간단한 연산으로 정한다.

- 요소를 13으로 나눈 나머지를 그 요소의 해시값으로 한다.
- 만들어진 **해시값**은 각 데이터에 접근할 때 사용된다.
- 그 해시값을 인덱스로 해서 인덱스와 키값을 저장한 배열을 **해시 테이블**이라고 한다.
- 키값을 해시값으로 변환하는 과정을 **해시함수**라고 한다.
- 해시 테이블의 각 요소를 **버킷**이라고 한다.

<br>

### 해시값 충돌

이전 해시함수인 “키값을 13으로 나눈 나머지는 해시값으로 한다”를 적용시킬 때

(해시테이블 크기가 13인 경우 대체로 사용하는 해시함수)

예를 들어 키값이 5와 18인 경우 둘 다 해시값이 5가 된다.

이렇게 저장할 버킷이 중복되는 현상을 충돌이라고 한다.

키값과 해시값은 무조건적으로 일대일대응은 아니며 보통 n대1의 관계를 가진다.

가능하면 해시값이 한부분으로 치우치지 않도록 고르게 분포될 수 있는 해시함수를 만드는 것이 관건

**충돌 대처법**

- 체인법
    
    해시값이 같은 요소를 연결리스트로 관리한다.
    
    각 버킷에 저장된 값은 해당 인덱스를 해시값으로 하는 연결리스트의 첫번째 노드이다.
    
    데이터가 하나도 없는 버킷은 null을 가리킨다.
    
    <br>
  
    **체인법 해시 프로그램 구성**
    
    - 버킷용 노드 클래스(key, data, nextNode)
        
        해시값을 반환하는 메소드 추가! hashCode(Object클래스)
        
    - 해시 클래스(size, table)
        
        생성자(capacity) → 모든 버킷값 null 참조로 초기화
        
        hashValue(key) → 키값을 size로 나눈 나머지 반환(해시값 반환)
        
    - search(K) → 키값으로 요소 검색, 해시값 얻은 후 연결리스트 선형 검색
    - add(K, V) → 키값과 데이터 삽입, 등록되지 않은 키값이면 리스트 맨 앞에 삽입
    - remove(K) → 키값을 가지는 요소 삭제, 해시값 얻은 후 삭제 노드를 찾으면 해당 참조를 다음 노드의 참조로 변경하거나 null을 가리키도록 변경하여 삭제
    - dump() → 해시 테이블 내용 출력, 모든 버킷에 대하여 연결되어 있는 노드의 키값과 데이터 출력

<br>

- 오픈주소법
    
    충돌이 발생했을 때 재해시를 수행해서 비어있는 버킷을 찾아낸다.
    
    닫힌 해시법이라고 한다.
    
    최악의 경우 해시테이블 전체를 탐색해야하는 수도..
    
    <br>
  
    **충돌했을 경우**
    
    삽입 → 빈 버킷을 만날 때까지 재해시를 반복한다. 선형 탐사법
    
    재해시 경우 해시메서드는 다른 것을 사용해도 됨
    
    삭제 → 연결리스트의 앞부분이 삭제되면 뒤에 연결된 노드들이 검색되지 않는다. 따라서 비어있는 상태와 삭제된 상태를 버킷에 명시한다.
    
    검색 → 버킷이 비어있는 경우에는 실패하지만 삭제가 된 상태라면 재해시로 다시 탐색한다.
    
    **오픈주소법 해시법 프로그램 구성**
    
    - 버킷의 상태를 나타내는 enum클래스, 버킷 생성자 및 상태 setter, 재해시 메서드만 추가되고 나머지는 체인법 프로그램과 비슷하다.

<br>

cf. 적당한 해시 테이블 만들기

해시 테이블을 크게 하면 당연히 충돌발생을 억제할 수 있지만 쓸데없는 메모리를 차지하는 문제가 생긴다. 시간과 공간의 효율을 생각해야 한다.
해시테이블 용량 이하의 정수를 되도록이면 한쪽으로 치우치지 않도록 고르게 만들어야 한다. 해시테이블의 용량은 소수가 좋다.

**왜 해시테이블의 용량은 소수가 좋을까?**

소수는 1과 자신을 제외한 수의 배수가 되지 않는다. 따라서 나머지가 상대적으로 고르게 나올 수 있는 가능성이 높아진다. 그리고 좋은 해시함수를 사용한다던가 더 좋은 방법이 있을 수 있지만 전통적으로 소수를 사용한다.

cf. 자바에서의 열거형

자바에서는 열거형 클래스인 enum을 지원한다. [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html)

관계있는 상수들끼리의 집합을 만들어주는 것
우리가 상수로 만드는 것들을 자동으로 클래스 안의 필드들로 생성해주고 손쉬운 사용을 제공한다.

Enum클래스에서 파생한 서브클래스로 컴파일되고 여러가지 메서드들이 상속되어 사용가능하다. ordinal(), name(), toString() 등
이외에 2차검색법(저장할 위치로부터 일정하게 떨어진 영역을 순서대로 검색해서 빈 곳에 저장하는 방법)이 있다.

## Q1_각 해시법에서 이름을 키값으로 변경

```java
class ChainHashTester {
    static Scanner stdIn = new Scanner(System.in);

    //--- 데이터(회원번호＋이름) ---//
    static class Data {
        static final int NO   = 1;        // 번호를 읽어 들일까요?
        static final int NAME = 2;        // 이름을 읽어 들일까요?

        private Integer no;                      // 회원번호
        private String  name;                    // 이름을 키값으로 변경

        //--- 키값 ---//
        String keyCode() {
            return name;
        }

...
//해시테이블 선언 및 사용할 때 키값타입 이름의 문자열로 변경
ChainHash<String, Data> hash = new ChainHash<String, Data>(13);
```