# 8장#2_배열커서_연결리스트

## 배열을 사용한 연결 리스트

노드 삽입 삭제를 데이터의 이동없이 할 수 있지만 기능을 수행할 때마다 메모리 영역을 확보, 해제하는 과정이 매번 필요하다.

데이터 수가 크게 변하지 않거나 이미 최대 개수를 아는 경우 배열을 사용하는 것이 효과적일 수 있다.

- 사실 포인터를 사용하는 것과 배열을 이용한다는 것 이외에 다르지 않다.
- 인덱스 포인터를 커서로 사용한다.
- 노드의 커서는 다음 노드가 저장되어있는 인덱스를 저장한다.
- 머리노드가 들어있는 곳은 인덱스 1이고 head값이다.

- 삭제한 노드 관리방법
    
    포인터를 이용한 연결리스트는 단순히  포인터를 그다음 노드로 넘겨주었지만 배열은 삭제를 진행할수록 빈 레코드가 중간중간 생기게 된다.
    
    따라서 삭제가 되는  인덱스들을 따로 프리리스트로 관리한다.
    
    연결리스트 클래스에서 삭제된 노드를 가리키는 필드를 추가한다.
    
    만약 노드를 삽입할 경우 프리리스트에서 인덱스를 하나 가져가 사용한다.
    

---

## 원형 이중 연결리스트

- null을 가리키는 포인터가 없이 꼬리 노드가 머리 노드를 가리키므로써 무한히 연결되는 리스트
- 다음 노드를 찾는것이 아닌 앞쪽 노드를 효율적으로 찾기 위해 앞쪽 노드에 대한 포인터를 이용한다.
- Node<E> 클래스
    - data
    - 앞쪽 포인터 : prev
    - 뒤쪽 포인터 : next
    - 처음에 생성 시 포인터가 자기 자신을 가리키는 노드 하나를 생성한다.
- DoubleIinkedList<E> 클래스
    - 머리 포인터 : head
    - 선택 포인터 : crnt
    - head.next()가 head라면 비어있는 리스트
    
    **search(E, Comparator)**
    
    **printCurrentNode()**
    
    **dump()**
    
    **dumpReverse()** → 모든 노드를 거꾸로 메소드
    
    - head.prev부터 시작해서 head로 돌아오면 스캔을 끝낸다.
    
    **next()**
    
    **prev()** → 선택 노드를 앞쪽으로 진행하는 메소드
    
    **add(E)**
    
    **addFirst(E)**
    
    **addLast(E)**
    
    **removeCurrentNode()**
    
    **remove(Node)**
    
    **removeFirst()**
    
    **removeLast()**
    
    **clear()**